// include statements

#include <stdio.h>
 // for printf(), scanf(), NULL, FILE, fopen()
#include <unistd.h>
 // for sleep()
#include <stdbool.h>
 // for bool type
#include <stdlib.h>
 // for malloc() & free()
#include <string.h>
 // for strlen(), strcmp(), memcpy() & memset()
#include <stdlib.h>
 // for srand(), rand()
#include <time.h>
 // for time()
#include <sys/socket.h>
 // for socket()
#include <sys/types.h>
 // for stat() and struct stat and pthread types
#include <sys/stat.h>
 // for stat() and struct stat type
#include <pthread.h>
 // for pthread function calls and pthread types
#include <netinet/in.h>
 // for struct in_addr

// ############################################################################
// constant and variable definitions
// ############################################################################
// function signatures

//void clienConnectionHandler(int pServerSocket);
//void serverConnectionHandler(int pClientSocket);

int initServerSocket(short * pClientSocket);
//int initClientSocket(u_short * pServerSocket);

//void actAsClient(u_short * pPortNo);
void actAsServer(short * pPortNo);

void connection_handler(int pClientSocket, bool * work);

int initSocket(short * pPortNo);

void runtime(short * pPortNo);

// ############################################################################
// main function definition

bool correctNumberOfArguments(int * pArgC)
{
	printf("start function correctNumberOfArguments\n");
	int correctNumArgs = 2; //for this program
	return (correctNumArgs == *pArgC);
	printf("end function correctNumberOfArguments\n");
}

bool equalStrings(char * pStr1, char * pStr2);

bool correctArgs(char * arg)
{
	printf("start correctargs with arg:\"%s\"\n",arg);
	bool retVal = true;
	// for this program
	char client[3] = "-c\0";
	char server[3] = "-s\0";

	//int res = equalStrings()
	//int res1 = strcmp(client,arg);
	//int res2 = strcmp(server,arg);

	if(equalStrings(client,arg))
	{
		printf("client\n");
	}
	else
	{
		printf("not client\n");
	}

	if(equalStrings(server,arg))
	{
		printf("server\n");
	}
	else
	{
		printf("not server\n");
	}
	printf("end correctargs with arg:\"%s\"\n",arg);
	return retVal;
}

int main(int argc, char * argv[])
{
	char arg[3];
	arg[0] = '-';
	arg[1] = 'c';
	arg[2] = 0;
	correctArgs(arg);
	arg[0] = '-';
	arg[1] = 's';
	arg[2] = 0;
	correctArgs(arg);
	printf("number of arguments: %d\n", argc);
	if(correctNumberOfArguments(&argc) && correctArgs(argv[1]) && false)
	{
		//run
		short portno = 10600;
		int sockfd;
		int clientsocket;
		int c;
		int read_size;
		struct sockaddr_in server;
		struct sockaddr_in client;
		char clientMSG[512];
		int bindstate = 0;
		int listenstate = 0;

		sockfd = socket(AF_INET, SOCK_STREAM, 0);
		if(sockfd < 0)
		{
			perror("could not create socket");
		}
		puts("socket created");

		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = portno;

		bindstate = bind(sockfd,(struct sockaddr *)&server, sizeof(server));

		if(bindstate < 0)
		{
			perror("Error: bind failed");
		}
		puts("bind done");

		listenstate = listen(sockfd,5);
		if(listenstate < 0)
		{
			perror("Error listen() call returned status -1");
		}
		puts("waiting for incoming connections");

		c = sizeof(struct sockaddr_in);

		clientsocket = accept(sockfd, (struct sockaddr *)&client, (socklen_t*)&c);
		if(clientsocket < 0)
		{
			perror("accept failed");
		}
		puts("connection accepted");

		read_size = recv(clientsocket,clientMSG,512,0);
		char * msgcheck = 0;
		while(read_size >
 0)
		{
			printf("message: %s",clientMSG);
			//strncasecmp()
			msgcheck = strstr(clientMSG,"close");
			send(clientsocket,clientMSG,strlen(clientMSG),0);
			if(msgcheck == 0)
			{
				read_size = recv(clientsocket,clientMSG,512,0);
			}
			else
			{
				read_size = 0;
			}
		}

		if(read_size == 0)
		{
			puts("client disconnected");
			fflush(stdout);
		}
		else if(read_size == -1)
		{
			perror("recv ended with code -1");
		}
	}
	else
	{
		printf("malformed command, specify run mode\nusage:\n");
		printf("for server mode\n%s -s\n",argv[0]);
		printf("for client mode\n%s -c\n",argv[0]);
		exit(0); //return 0;
	}
	//printf("size of int: %lu\n",sizeof(int));
	//printf("size of short: %lu\n",sizeof(short));
	//printf("size of u_short: %lu\n",sizeof(u_short));
	//printf("size of uint16_t: %lu\n",sizeof(uint16_t));



	return 0;
}

bool equalStrings(char * pStr1, char * pStr2)
{
	bool retVal = true;
	int strlen1 = strlen(pStr1);
	int strlen2 = strlen(pStr2);
	bool stessalen =(strlen1 == strlen2);
	bool equal = (strncmp(pStr1,pStr2,strlen1) == 0);
	if(stessalen)
	{
		printf("stessa len\n");
	}
	if(equal)
	{
		printf("equal\n");
	}
	if(!stessalen || !equal)
	{
		retVal = false;
	}
	return retVal;
}

void runtime(short * pPortNo)
{
	//bool KingOrPeasant = true; //true ->
 server by default


}
// ############################################################################
// function definitions

/**********************************************************************/
/* This function starts the process of listening for web connections
 * on a specified port.
 * Parameters: pointer to variable containing the port to connect on
 * Returns: the socket */
/**********************************************************************/
int initServerSocket(short * pClientSocket)
{
	int sockfd = 0;
	//int httpd = 0;
	struct sockaddr_in name;

	sockfd = socket(PF_INET, SOCK_STREAM, 0);

	if(sockfd < 0)
	{
		perror("socket");
		exit(1);
	}

	int opt = 1; //option value
	/*option to reuse the port assigned*/
	int setopt = 0;
	setopt = setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

	if (setopt < 0)
	{
		perror("set reuse port option");
		exit(1);
	}

	memset(&name, 0, sizeof(name));
	name.sin_family = AF_INET;
	name.sin_port = htons(*pClientSocket);
	name.sin_addr.s_addr = htonl(INADDR_ANY);

	if(bind(sockfd, (struct sockaddr *)&name, sizeof(name)) < 0)
	{
		perror("bind");
		exit(1);
	}

	if(listen(sockfd, 5) < 0)
	{
		perror("listen");
		exit(1);
	}
	return sockfd;
}

void actAsServer(short * pPortNo)
{

}
